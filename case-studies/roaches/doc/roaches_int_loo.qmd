---
title: "Integrated loo for roaches example"
author: Anna Elisabeth Riha, Aki Vehtari
format: html
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

```{r}
# setup ####
library(rstanarm)
library(brms)
library(cmdstanr)
options(mc.cores = parallel::detectCores())
library(loo)
library(ggplot2)
library(bayesplot)
theme_set(bayesplot::theme_default(base_family = "sans"))
library(tidyverse)
library(tictoc)
```

```{r}
# load data
data(roaches)
# Roach1 is very skewed and we take a square root
roaches$sqrt_roach1 <- sqrt(roaches$roach1)
# stan file
poisson_re_int <- here::here("case-studies", "roaches", "Stan", "poisson_re_integrate.stan")
```

```{r}
# compile model
modpri <- cmdstanr::cmdstan_model(stan_file = poisson_re_int, force_recompile = TRUE, quiet = FALSE)

# prepare data
datap <- list(N=dim(roaches)[1], 
              P=3,
              offsett=log(roaches$exposure2),
              X=roaches[,c('sqrt_roach1','treatment','senior')],
              y=roaches$y)
```

```{r}
#| include: false
# sample
fitpri <- modpri$sample(data = datap, refresh=0, chains=8, parallel_chains=4)
```

```{r}
# custom function for computing elpd, p_loo etc.
loocmd <- function(fit) {
  loo(fit$draws("log_lik"), r_eff=relative_eff(fit$draws("log_lik")))
}

(loopri <- loocmd(fitpri))
```

```{r}
# summarise draws
draws_summary <- posterior::summarise_draws(fitpri) |> as_tibble()

# check bulk ESS of log_lik values
# recommendations from https://mc-stan.org/misc/warnings.html
draws_summary |> 
  select(variable, rhat, ess_tail, ess_bulk) |>
  filter(str_detect(variable, "^log_lik")) |> 
  count(ess_bulk < (8 * 100))
```

```{r}
# get draws
draws_df <- fitpri$draws(format = "data.frame") |>
  as_tibble() 

# reformat draws to combine z's (and beta's) as vectors for each iteration in each chain
input_df <- draws_df |> 
  select(-matches("log_lik")) |>
  tidyr::nest(zs = starts_with("z"),
              sigmaz = matches("sigmaz"),
              alpha = matches("alpha"),
              beta = matches("beta")) |>
  mutate(zs = map(zs, unlist),
         sigmaz = map_dbl(sigmaz, ~matrix(unlist(.x), ncol = 1)),
         alpha = map_dbl(alpha, ~matrix(unlist(.x), ncol = 1)),
         beta = map(beta, ~matrix(unlist(.x), ncol = 3)))

head(input_df)
```

# get linear predictor without random effect

```{r}
get_linpred_roaches <- function(alpha, beta, offset, covariates){
  linpreds_minus_re = offset + alpha + rowSums(covariates * unlist(beta))
  return(linpreds_minus_re)
}

## test for one row 
#linpred_one <- get_linpred_roaches(
#  alpha = input_df[1,]$alpha, 
#  beta = input_df[1,]$beta,
#  offset = log(roaches$exposure2), 
#  covariates = roaches[,c('sqrt_roach1','treatment','senior')]
#  )

input_df <- input_df |>
  mutate(linpreds_minus_re = pmap(list(alpha, beta),
                         get_linpred_roaches, 
                         offset = log(roaches$exposure2), 
                         covariates = roaches[,c('sqrt_roach1','treatment','senior')]))
```

# Evaluate integral with `integrate()`

Instead of including `offsettj_plus_alpha`, `Xj`, and `beta`, we combine them into `linpred_minus_re` beforehand. The idea is to use `brms::posterior_linpred()` lateron. 

```{r integrand with linpred}
# define integrand as function  ####
# in Stan code: normal_lpdf(z|0,sigmaz)+poisson_log_glm_lpmf(yi | to_row_vector(Xi), z+offsetti_plus_alpha, beta)
integrand_linpred <- function(zs, 
                              muz,
                              sigmaz,
                              y, 
                              linpreds_minus_re){
  
  # function defines integrand for integrate()
  # combines prior on obs-level random effect z and likelihood

  # in Stan code: normal_lpdf(z|0,sigmaz)
  z_term <- dnorm(zs,
                  mean = muz, 
                  sd = sigmaz,
                  log = TRUE)
    
  # in Stan code: poisson_log_glm_lpmf(yi | to_row_vector(Xi), z+offsetti_plus_alpha, beta)
  fit_term <- dpois(x = y, 
                    lambda = exp(zs + linpreds_minus_re),
                    log = TRUE)
  
  result = exp(z_term + fit_term)
  return(result)
}

```

# evaluate integral

```{r testing integral linpred}
# test
# one value 
integrand_linpred(zs = as.numeric(unlist(input_df[1,]$zs)[1]), 
                  muz = 0,
                  sigmaz = input_df[1,]$sigmaz, 
                  y = as.numeric(roaches$y[1]),
                  linpreds_minus_re = unlist(input_df[1,]$linpreds_minus_re)[1])

# evaluate integral for one value
integrate(integrand_linpred, 
          lower = -(9 * input_df[1,]$sigmaz), 
          upper = 9 * input_df[1,]$sigmaz,
          muz = 0,
          sigmaz = input_df[1,]$sigmaz, 
          y = as.numeric(roaches$y[1]),
          linpreds_minus_re = unlist(input_df[1,]$linpreds_minus_re)[1])

# 262 values
integrand_linpred(zs = as.numeric(unlist(input_df[1,]$zs)), 
                  muz = 0,
                  sigmaz = input_df[1,]$sigmaz, 
                  y = as.numeric(roaches$y),
                  linpreds_minus_re = unlist(input_df[1,]$linpreds_minus_re))

# not straightforward to evaluate integral for all 262 values, though
```

# get log_lik values with nested for-loop

```{r loglik via for loop}
# get log_lik values with nested for loop
# this takes quite a while (roughly 8 mins)
# add stop.on.error=FALSE to avoid stopping when "Integral is probably divergent" 

log_lik <- matrix(data=NA, nrow = 8000, ncol = 262)

tic()
for (i in seq(NROW(input_df))){
  for (j in seq(NROW(roaches))){
    #print(i)
    #print(j)
    sigmaz <- input_df[i,]$sigmaz
    linpreds_minus_re <- unlist(input_df[i,]$linpreds_minus_re)[j]
    y = as.numeric(roaches$y)[j]
    #print(paste0("Iteration: ", i, " sigmaz: ", sigmaz, " linpreds: ", linpreds_minus_re, " y: ", y))
    log_lik[i,j] <- log(integrate(integrand_linpred, 
                           lower = -(7 * sigmaz),
                           upper = 7 * sigmaz,
                           muz = 0,
                           sigmaz = sigmaz, 
                           y = y,
                           linpreds_minus_re = linpreds_minus_re,
                           stop.on.error = FALSE)$value)
    }
}
toc()
```
```{r loo with integrated log lik values}


# add names to matrix 
colnames(log_lik) <- paste0("log_lik[", 1:NROW(roaches), "]")

# following loo documentation: "For use with the loo() function, the values in x (or generated by x, if a function) should be likelihood values (i.e., exp(log_lik)), not on the log scale."


# convert matrix of log_lik values to array
log_lik_array <- array(log_lik, c(1000, 8, NROW(roaches)))

dimnames(log_lik_array) <- list(iteration = 1:1000,
                                chain = 1:8,
                                variable =  paste0("log_lik[", 1:NROW(roaches), "]"))
# convert into draws array
log_lik_array <- posterior::as_draws(log_lik_array)

loo(log_lik_array, r_eff = relative_eff(exp(log_lik_array)))
```

# Speed up with Gauss Hermite quadrature

```{r integrand for gauss hermite}
# define integrand as function  ####
# in Stan code: normal_lpdf(z|0,sigmaz)+poisson_log_glm_lpmf(yi | to_row_vector(Xi), z+offsetti_plus_alpha, beta)
integrand_ghq <- function(zs, 
                          y, 
                          linpreds_minus_re){
  
  # function defines integrand for integrate()
  # combines prior on obs-level random effect z and likelihood
    
  # in Stan code: poisson_log_glm_lpmf(yi | to_row_vector(Xi), z+offsetti_plus_alpha, beta)
  fit_term <- dpois(x = y, 
                    lambda = exp(zs + linpreds_minus_re))
  
  result = fit_term
  return(result)
}
```

```{r testing gauss hermite}
library(spatstat)

gauss.hermite(integrand_ghq, mu = 0, sd = 1, y = 1, linpreds_minus_re = 2, order = 10)

# compare to integrate()
integrate(integrand_linpred, 
          lower = -(7 * 1),
          upper = 7 * 1,
          muz = 0,
          sigmaz = 1, 
          y = 1,
          linpreds_minus_re = 2,
          stop.on.error = FALSE)$value
```

# WIP: evaluate integral with rowwise mapping

```{r}

get_loglik_obswise <- function(sigmaz, linpreds_minus_re, y){
  #sigmaz <- input_df[i,]$sigmaz
  #linpreds_minus_re <- unlist(input_df[i,]$linpreds_minus_re)[j]
  #y = as.numeric(roaches$y)[j]
  #print(paste0("Iteration: ", i, " sigmaz: ", sigmaz, " linpreds: ", linpreds_minus_re, " y: ", y))
  log_lik[i,j] <- integrate(integrand_linpred, 
                           lower = -(7 * sigmaz),
                           upper = 7 * sigmaz,
                           muz = 0,
                           sigmaz = sigmaz, 
                           y = y,
                           linpreds_minus_re = linpreds_minus_re,
                           stop.on.error = FALSE)$value
  
}

#input_df <- input_df |>
#  rowwise() |>
  
```

```{r}
# evaluate integral for 262 values
# https://stackoverflow.com/questions/15921090/r-integrate-at-each-point-of-array
evaluate_integral <- function(fun, sigmaz, y, linpreds_minus_re){
  return( integrate(fun, 
                    lower = -(9 * sigmaz),
                    upper = 9 * sigmaz,
                    muz = 0,
                    sigmaz = sigmaz, 
                    y = y,
                    linpreds_minus_re = linpreds_minus_re)
          )
}
```

```{r}
input_df <- input_df |> 
  mutate(y = list(as.numeric(roaches$y)))

test_row <- input_df[1,]

evaluate_integral(
  integrand_linpred, 
  sigmaz = test_row$sigmaz, 
  y = unlist(test_row$y)[1], 
  linpred_minus_re = unlist(test_row$linpreds_minus_re)[1])

linpred_minus_re = unlist(input_df[1,]$linpreds)

sapply(input_df[1,]$zs, function(z_vec) evaluate_integral(integrand_linpred, z_vec))

test_row <- input_df[1,] |>
  mutate(log_lik = pmap(list(zs, sigmaz, linpreds), 
                            evaluate_integral, 
                            fun = integrand_linpred,
                            y = as.numeric(roaches$y)))

sapply(test_row, function() evaluate_integral(test_row))

integrate(integrand_linpred, 
          lower = -(9 * input_df[1,]$sigmaz), 
          upper = 9 * input_df[1,]$sigmaz,
          muz_j = rep(0, 262),
          sigmaz_j = rep(input_df[1,]$sigmaz, 262), 
          y_j = as.numeric(roaches$y),
          linpred_j_minus_re = unlist(input_df[1,]$linpreds))

# test
# compare the above result to rnorm() with sd=sigmaz_j
z_norm <- rnorm(100000, sd =  input_df[1,]$sigmaz)
mean(dpois(
  x = as.numeric(roaches$y[1]), 
  lambda = exp(z_norm + unlist(input_df[1,]$linpreds)[1]),
  log = FALSE))
```

```{r integrand one iter}
# define integrand as function ####
integrand_iter <- function(zs_vec, 
                      muz_j, 
                      sigmaz_j,
                      y, 
                      X,
                      offsett_plus_alpha,
                      beta){
  
  # function defines integrand for integrate()
  # combines prior on obs-level random effect z and likelihood
  
  z_term <- dnorm(zs_vec,
                  mean = muz_j, 
                  sd = sigmaz_j,
                  log = TRUE)
  
  fit_term <- dpois(x = y, 
                    lambda = exp(zs_vec + offsett_plus_alpha + rowSums(X * beta)),
                    log = TRUE)
  
  result = exp(z_term + fit_term)
  return(result)
}

```

```{r test one iter}
# test for one iteration 
# vector of random intercept for each obs
zs_vec <- as.numeric(unlist(draws_df[1,]$zs)) 
# scale for z 
sigmaz <- unlist(draws_df[1,]$sigmaz) 

# targets
y <- as.numeric(roaches$y) 

# linpred without random effect 
linpred_
# covariates
X <- roaches[,c('sqrt_roach1','treatment','senior')]
offsett_plus_alpha <- log(roaches$exposure2) + unlist(draws_df[1,]$alpha)
beta <- unlist(draws_df[1,]$beta)

# linear pred for one iteration
linpreds_minus_ri <- offsett_plus_alpha + rowSums(X * beta)
linpreds <- zs_vec + offsett_plus_alpha + rowSums(X * beta)

# model prediction, applying exp() link function 
exp(linpreds)
```


# Compare to exposed Stan function

```{r expose Stan funs}
# expose Stan functions
modpri <- cmdstanr::cmdstan_model(stan_file = poisson_re_int, force_recompile=TRUE, compile_standalone = TRUE)
#modpri$expose_functions(global = TRUE)
#modpri$functions

# using code from https://rok-cesnovar.github.io/misc/exposing_cmdstanr_udf.html
source(here::here("case-studies", "roaches", "R", "expose_cmdstanr_functions.R"))

integrand_stan_code <- "
functions {
  real integrand(real z, real notused, array[] real theta, array[] real Xi, array[] int yi) {
      real sigmaz = theta[1];
      real offsetti_plus_alpha = theta[2]; 
      int ntheta = num_elements(theta);
      vector[ntheta-2] beta = to_vector(theta[3:ntheta]);
      return exp(normal_lpdf(z|0,sigmaz)+poisson_log_glm_lpmf(yi | to_row_vector(Xi), z+offsetti_plus_alpha, beta));
  }
}
"

# write integrand function to Stan file 
integrand_stan_file <- cmdstanr::write_stan_file(code = integrand_stan_code)

# exposing user-defined functions to access integrand function 
udfs <- expose_cmdstanr_functions(model_path = integrand_stan_file)
```

```{r}
# comparing to results using exposed Stan function ####
theta <- c(sigmaz_j, offsettj_plus_alpha, beta)
Xj_row_vec <- t(unlist(Xj))

#udfs$integrand(z, NULL, theta = theta, Xi = Xj_row_vec, yi = yj)
# currently returns: Error: Expecting a single value: [extent=0].
```

