---
title: "Integrated loo for roaches example"
author: Anna Elisabeth Riha, Aki Vehtari
format: html
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

```{r}
# setup ####
library(rstanarm)
library(brms)
library(cmdstanr)
options(mc.cores = parallel::detectCores())
library(loo)
library(ggplot2)
library(bayesplot)
theme_set(bayesplot::theme_default(base_family = "sans"))
library(tidyverse)
```

```{r}
# load data
data(roaches)
# Roach1 is very skewed and we take a square root
roaches$sqrt_roach1 <- sqrt(roaches$roach1)
# stan file
poisson_re_int <- here::here("case-studies", "roaches", "Stan", "poisson_re_integrate.stan")
```

```{r}
# compile model
modpri <- cmdstanr::cmdstan_model(stan_file = poisson_re_int)

# prepare data
datap <- list(N=dim(roaches)[1], 
              P=3,
              offsett=log(roaches$exposure2),
              X=roaches[,c('sqrt_roach1','treatment','senior')],
              y=roaches$y)
```

```{r}
# sample
fitpri <- modpri$sample(data = datap, refresh=0, chains=8, parallel_chains=4)
```

```{r}
# get draws
draws_df <- fitpri$draws(format = "data.frame") |>
  as_tibble() 

# reformat draws to combine z's (and beta's) as vectors for each iteration in each chain
draws_df <- draws_df |> 
  select(-matches("log_lik")) |>
  tidyr::nest(zs = starts_with("z"),
              sigmaz = matches("sigmaz"),
              alpha = matches("alpha"),
              beta = matches("beta")) |>
  mutate(zs = map(zs, unlist),
         sigmaz = map(sigmaz, ~matrix(unlist(.x), ncol = 1)),
         alpha = map(alpha, ~matrix(unlist(.x), ncol = 1)),
         beta = map(beta, ~matrix(unlist(.x), ncol = 3)))

head(draws_df)
```

```{r}
# summarise draws
draws_summary <- posterior::summarise_draws(fitpri) |> as_tibble()
head(draws_summary)
```

```{r expose Stan funs}
# expose Stan functions
#modpri <- cmdstanr::cmdstan_model(stan_file = poisson_re_int, compile_standalone = TRUE)
#modpri$expose_functions(global = TRUE)
#modpri$functions

# using code from https://rok-cesnovar.github.io/misc/exposing_cmdstanr_udf.html
source(here::here("case-studies", "roaches", "R", "expose_cmdstanr_functions.R"))

integrand_stan_code <- "
functions {
  real integrand(real z, real notused, array[] real theta, array[] real Xi, array[] int yi) {
      real sigmaz = theta[1];
      real offsetti_plus_alpha = theta[2]; 
      int ntheta = num_elements(theta);
      vector[ntheta-2] beta = to_vector(theta[3:ntheta]);
      return exp(normal_lpdf(z|0,sigmaz)+poisson_log_glm_lpmf(yi | to_row_vector(Xi), z+offsetti_plus_alpha, beta));
  }
}
"

# write integrand function to Stan file 
integrand_stan_file <- cmdstanr::write_stan_file(code = integrand_stan_code)

# exposing user-defined functions to access integrand function 
udfs <- expose_cmdstanr_functions(model_path = integrand_stan_file)
```

```{r integrand}
# define integrand as function  ####
# in Stan code: normal_lpdf(z|0,sigmaz)+poisson_log_glm_lpmf(yi | to_row_vector(Xi), z+offsetti_plus_alpha, beta)
integrand <- function(zs_vec, 
                      muz_j, 
                      sigmaz_j,
                      yj, 
                      Xj,
                      offsettj_plus_alpha,
                      beta){
  
  # function defines integrand for integrate()
  # combines prior on obs-level random effect z and likelihood
  
  # in Stan code: normal_lpdf(z|0,sigmaz)
  z_term <- dnorm(zs_vec,
                  mean = muz_j, 
                  sd = sigmaz_j,
                  log = TRUE)
  
  # in Stan code: poisson_log_glm_lpmf(yi | to_row_vector(Xi), z+offsetti_plus_alpha, beta)
  fit_term <- dpois(x = yj, 
                    lambda = exp(zs_vec + offsettj_plus_alpha + sum(Xj * t(beta))),
                    log = TRUE)
  
  #dlik(yj, link(zs_vec + linpred_minus_re))
  
  result = exp(z_term + fit_term)
  return(result)
}

```

```{r test}
# test for one iteration and one observation

# random intercept for each obs
z <- as.numeric(unlist(draws_df[1,]$zs)[1]) 
muz_j <- 0

# scale for z 
sigmaz_j <- unlist(draws_df[1,]$sigmaz) 

# target
yj <- as.numeric(roaches$y[1]) 

# covariates
Xj <- roaches[1,c('sqrt_roach1','treatment','senior')]
offsettj_plus_alpha <- log(roaches$exposure2[1]) + unlist(draws_df[1,]$alpha)
beta <- unlist(draws_df[1,]$beta)

# linear pred for one iteration and one observation
linpred_minus_ri <- offsettj_plus_alpha + sum(Xj * t(beta))
linpred <- z + offsettj_plus_alpha + sum(Xj * t(beta))

# model prediction, applying exp() link function 
exp(linpred)
```

```{r evaluate integral}
# evaluate integral ####
integrate(integrand, 
          lower = -(9 * sigmaz_j), 
          upper = 9 * sigmaz_j,
          muz_j = 0, # random intercept mean (here: 0)
          sigmaz_j = sigmaz_j, 
          yj = yj, 
          Xj = Xj,
          offsettj_plus_alpha = offsettj_plus_alpha,
          beta = beta
          )
```

```{r}
# compare the above result to rnorm() with sd=sigmaz_j
z_norm <- rnorm(100000, sd = sigmaz_j)
mean(dpois(
  x = yj, 
  lambda = exp(z_norm + offsettj_plus_alpha + sum(Xj * t(beta))),
  log = FALSE))
```

```{r test sigma small}
# test case 1: for sigmaz close to zero, compare to dpois() with zs_vec = 0 
sigmaz_zero <- 1e-10
integrate(integrand, 
          lower = -(9 * sigmaz_zero), 
          upper = 9 * sigmaz_zero,
          muz_j = 0, # random intercept mean (here: 0)
          sigmaz_j = sigmaz_zero, 
          yj = yj, 
          Xj = Xj,
          offsettj_plus_alpha = offsettj_plus_alpha,
          beta = beta
          )

# compare to dpois() with z=0
dpois(x = yj, lambda = exp(0 + offsettj_plus_alpha + sum(Xj * t(beta))), log = FALSE)
```

```{r test sigma big}
# test case 2: for sigmaz big enough, result of integrate() should roughly be the same as mean(dpois()) with zs_vec = rnorm(10000)
sigmaz_big <- 0.99
integrate(integrand, 
          lower = -(9 * sigmaz_big), 
          upper = 9 * sigmaz_big,
          muz_j = 0, # random intercept mean (here: 0)
          sigmaz_j = sigmaz_big, 
          yj = yj, 
          Xj = Xj,
          offsettj_plus_alpha = offsettj_plus_alpha,
          beta = beta
          )

# compare to samples from normal distr. and mean(dpois(...)), using rnorm() defaults means that we assume sigmaz=1
zs_norm <- rnorm(10000) 
mean(dpois(x = yj, 
           lambda = exp(zs_norm + offsettj_plus_alpha + sum(Xj * t(beta))),
           log = FALSE))
```

```{r}
# comparing to results using exposed Stan function ####
theta <- c(sigmaz_j, offsettj_plus_alpha, beta)
Xj_row_vec <- t(unlist(Xj))

#udfs$integrand(z, NULL, theta = theta, Xi = Xj_row_vec, yi = yj)
# currently returns: Error: Expecting a single value: [extent=0].
```





